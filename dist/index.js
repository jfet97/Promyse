module.exports=function(t){var e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)r.d(n,o,function(e){return t[e]}.bind(null,o));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";r.r(e);const n={PENDING:"PENDING",FULFILLED:"FULFILLED",REJECTED:"REJECTED"};class o{constructor(t=n.PENDING,e,r=!1){Object.assign(this,{_state:t,_value:e,_settled:r})}get value(){return this._value}get state(){return this._state}get settled(){return this._settled}}class s{constructor(){this.observers=[]}add({onfulfill:t,onreject:e}){this.observer.push({onfulfill:t,onreject:e})}get(){this.observer.shift()}get hasNext(){return this.observers.length}}r.d(e,"Promyse",function(){return c});const i=new WeakMap,l=new Map;class c{constructor(t){if("function"!=typeof t)throw new TypeError("The executor must be a function");i.set(this,new o),l.set(this,new s);try{t(function(t){if(this===t)throw TypeError("Cannot solve a Promyse with itself");const e=i.get(this);if(!e.settled){if(t instanceof c)t.then(t=>{i.set(this,new o(n.FULFILLED,t,!0))},t=>{a.call(this,t)});else if(void((r=t)===Object(r)&&r.then)){let e=null;try{e=t.then}catch(t){return void a.call(this,t)}if("function"==typeof e)try{e.call(t,t=>{i.get(this).settled||i.set(this,new o(n.FULFILLED,t,!0))},t=>{i.get(this).settled||a.call(this,t)})}catch(t){i.get(this).settled||a.call(this,t)}else i.set(this,new o(n.FULFILLED,t,!0))}else i.set(this,new o(n.FULFILLED,t,!0));const s=l.get(this);for(;s.hasNext;){const{onfulfill:t}=s.get();Promise.resolve().then(()=>t(e.value))}l.delete(this)}var r}.bind(this),a.bind(this))}catch(t){a.call(this,t)}}then(t,e){"function"!=typeof t&&(t=t=>t),"function"!=typeof e&&(e=t=>{throw t});let r=null;const o=i.get(this);return r=o.settled?new c((r,s)=>{if(o.state===n.FULFILLED)try{r(t(o.value))}catch(t){s(t)}else try{s(e(o.value))}catch(t){s(t)}}):new c((e,r)=>{l.get(this).add({onfulfill:n=>{try{e(t(n))}catch(t){r(t)}},onreject:e=>{try{r(t(e))}catch(t){r(t)}}})})}catch(t){return this.then(null,t)}finally(t){return"function"!=typeof t&&(onfulfill=t=>t),this.then(e=>{try{return t()instanceof c?t().then(()=>e):e}catch(t){throw t}},e=>{try{if(t()instanceof c)return t().then(()=>{throw e});throw e}catch(t){throw t}})}static resolve(t){return t instanceof c?t:new c(e=>{e(t)})}static reject(t){return t instanceof c?t:new c((e,r)=>{r(t)})}static all(t){if(t===Object(t)&&"function"==typeof t[Symbol.iterator]){const e=[...t].map(t=>c.resolve(t)),r=e.length;return new c(0===r?t=>t([]):(t,n)=>{let o=[];e.forEach((e,s)=>{e.then(e=>{o[s]=e,o.map(t=>t).length===r&&t(o)},t=>n(t))})})}throw new TypeError(`Cannot read property 'Symbol(Symbol.iterator)' of ${String(t)}.`)}static any(t){if(t===Object(t)&&"function"==typeof t[Symbol.iterator]){const e=[...t].map(t=>c.resolve(t)),r=e.length;return new c(0===r?t=>t([]):(t,n)=>{let o=[];e.forEach((e,n)=>{e.then(e=>t(e),t=>{o[n]=t,o.map(t=>t).length===r&&rejected(o)})})})}throw new TypeError(`Cannot read property 'Symbol(Symbol.iterator)' of ${String(t)}.`)}static allSettled(t){if(t===Object(t)&&"function"==typeof t[Symbol.iterator]){const e=[...t].map(t=>c.resolve(t)),r=e.length;return new c(0===r?t=>t([]):(t,n)=>{let o=[];function s(e,n){o[n]=e,o.map(t=>t).length===r&&t(o)}e.forEach((t,e)=>{t.then(t=>s(t,e),t=>s(t,e))})})}throw new TypeError(`Cannot read property 'Symbol(Symbol.iterator)' of ${String(t)}.`)}static race(t){if(t===Object(t)&&"function"==typeof t[Symbol.iterator]){const e=[...t].map(t=>c.resolve(t));return new c((t,r)=>{e.forEach(e=>{e.then(e=>t(e),t=>r(t))})})}throw new TypeError(`Cannot read property 'Symbol(Symbol.iterator)' of ${String(t)}.`)}}function a(t){const e=i.get(this);if(!e.settled){i.set(this,new o(n.REJECTED,t,!0));const r=l.get(this);for(;r.hasNext;){const{onreject:t}=r.get();Promise.resolve().then(()=>t(e.value))}l.delete(this)}}}]);